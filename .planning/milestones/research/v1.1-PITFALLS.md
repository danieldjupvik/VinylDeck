# Pitfalls Research: API Migration (v1.1)

**Domain:** Hybrid dual-library API architecture migration
**Researched:** 2026-02-03
**Confidence:** HIGH (based on documented discojs issues + TypeScript patterns)

## Executive Summary

Migrating from 738 lines of custom types to a hybrid @lionralfs + discojs architecture carries specific risks around library integration, type compatibility, and rate limiting coordination. The most critical pitfalls are query param casing bugs in discojs, type incompatibilities between libraries, and module augmentation footguns.

---

## Critical Pitfalls

### Pitfall 1: Query Param Casing Silently Breaks Searches

**What goes wrong:**

discojs does NOT convert camelCase query params to snake_case when making GET requests. The `addQueryToUri()` method passes params as-is to URLSearchParams. Discogs API expects snake_case and silently ignores unknown params, returning broader/incorrect results.

**Example:**

```typescript
// What you pass
client.getCollectionFolder(username, folderId, { releaseTitle: 'Abbey Road' })

// What discojs sends
GET /users/{username}/collection/folders/{id}/releases?releaseTitle=Abbey+Road

// What Discogs expects
GET /users/{username}/collection/folders/{id}/releases?release_title=Abbey+Road

// Result: Discogs ignores releaseTitle, returns all releases
```

**Why it happens:**

discojs `transformData()` only converts POST/PUT body params to snake_case, not GET query params. The `addQueryToUri()` method at `fetch.ts:259-268` has no transformation logic.

**Consequences:**

- Search features silently fail
- Pagination params may not work
- Sorting/filtering breaks without errors
- Tests pass if you don't verify param names on wire

**Prevention:**

1. DO NOT use discojs query param options until verified fixed
2. If using discojs for data calls, manually convert params:
   ```typescript
   const snakeCaseParams = {
     release_title: options.releaseTitle,
     per_page: options.perPage
   }
   ```
3. Add integration tests that verify actual query strings sent
4. Consider contributing fix upstream or maintaining fork

**Detection:**

- Network tab shows camelCase params in URLs
- API returns unexpected number of results
- Pagination/sorting doesn't respect options

**Which phase:**

Phase 1 (integration) - Must verify before switching from @lionralfs to discojs for any GET requests with params.

---

### Pitfall 2: Rate Limit Metadata Loss

**What goes wrong:**

discojs uses Bottleneck for throttling but does NOT expose rate limit metadata to consumers. VinylDeck's tRPC layer currently returns `{ data, rateLimit }` with remaining/limit info. Switching to discojs means losing this functionality.

**Why it happens:**

Bottleneck tracks limits internally. discojs fetches rate limit headers from responses but doesn't surface them in return values. The public API only returns decoded data.

**Consequences:**

- UI can't show "X requests remaining"
- No proactive warnings before hitting limits
- Can't implement smart retry backoff based on capacity
- Breaks existing tRPC contract if not handled

**Prevention:**

1. **Wrapper approach:** Create facade that intercepts responses before discojs processes them:

   ```typescript
   class RateLimitedDiscogsClient {
     private lastRateLimit: RateLimitInfo | null = null

     async getCollection(...args) {
       // Manually fetch and parse headers before passing to discojs
       const response = await fetch(url, options)
       this.lastRateLimit = this.parseRateLimitHeaders(response.headers)
       const data = await response.json()
       return { data, rateLimit: this.lastRateLimit }
     }
   }
   ```

2. **Extend discojs:** Fork or use module augmentation to add rate limit tracking to return types

3. **Extract from Bottleneck:** Access Bottleneck instance internals (fragile, not recommended)

**Detection:**

- tRPC responses missing `rateLimit` field
- UI components that use rate limit data error/fail
- Tests expect rate limit metadata

**Which phase:**

Phase 1 (integration) - Must solve before replacing tRPC router implementation.

---

### Pitfall 3: Token Handoff Type Mismatch

**What goes wrong:**

OAuth tokens from @lionralfs's `getAccessToken()` flow might not serialize/deserialize identically when passed to discojs constructor.

**Why it happens:**

Both libraries use OAuth 1.0a but may have different internal representations. If VinylDeck stores tokens in a format specific to @lionralfs, deserializing for discojs could fail silently or with obscure errors.

**Consequences:**

- 401 errors on first discojs call after OAuth
- Token refresh loops
- Users forced to re-authenticate

**Prevention:**

1. **Verify token format compatibility:**

   ```typescript
   // After @lionralfs OAuth flow
   const tokens = await oauthClient.getAccessToken(...)
   console.log('Token format:', typeof tokens, Object.keys(tokens))

   // Pass to discojs
   const discogsClient = new Discojs({
     consumerKey,
     consumerSecret,
     oAuthToken: tokens.oauthToken,        // Check property names
     oAuthTokenSecret: tokens.oauthTokenSecret
   })
   ```

2. **Add integration test:** OAuth flow via @lionralfs → API call via discojs

3. **Document token contract:** Type both sides explicitly:
   ```typescript
   interface OAuthTokens {
     oauthToken: string
     oauthTokenSecret: string
   }
   ```

**Detection:**

- 401 errors immediately after successful OAuth
- discojs throws "Invalid signature" errors
- Tokens work with @lionralfs, fail with discojs

**Which phase:**

Phase 1 (integration) - Critical blocker for dual-library approach.

---

### Pitfall 4: Module Augmentation Overwrites Instead of Merging

**What goes wrong:**

When augmenting discojs types to add missing fields like `avatar_url`, TypeScript may OVERWRITE the original interface instead of MERGING, losing all original fields.

**Example:**

```typescript
// WRONG - overwrites entire interface
declare module 'discojs' {
  interface IdentityIO {
    avatar_url?: string
  }
}

// All original fields lost!
```

**Why it happens:**

Module augmentation only merges if you import from the module in the same file. Without an import, TypeScript treats it as a new declaration, not an augmentation.

**Consequences:**

- All original type fields disappear
- Compilation errors cascade through codebase
- Runtime data exists but TypeScript can't see it

**Prevention:**

1. **Always import when augmenting:**

   ```typescript
   // types/discogs-augmentation.ts
   import type { IdentityIO } from 'discojs' // REQUIRED

   declare module 'discojs' {
     interface IdentityIO {
       avatar_url?: string
       banner_url?: string
     }
   }
   ```

2. **Add integration test that accesses both original and augmented fields:**

   ```typescript
   const identity: IdentityIO = getIdentity()
   expect(identity.id).toBeDefined() // Original field
   expect(identity.avatar_url).toBeDefined() // Augmented field
   ```

3. **Only augment with optional fields** - Required fields break library code that constructs objects

**Detection:**

- TypeScript errors on discojs types: "Property 'id' does not exist on type 'IdentityIO'"
- IntelliSense only shows augmented fields, not originals
- Runtime values exist but TypeScript can't access them

**Which phase:**

Phase 2 (type migration) - Happens when adding module augmentation file.

---

## Moderate Pitfalls

### Pitfall 5: Type Strictness Mismatch Between Libraries

**What goes wrong:**

@lionralfs marks some fields as required that discojs marks as optional, or vice versa. Code written for @lionralfs types breaks when switching to discojs types.

**Example:**

```typescript
// With @lionralfs types
const title = release.basic_information.title // OK, title is required

// With discojs types
const title = release.basic_information.title // Error if title is optional
```

**Prevention:**

1. **Audit type differences before migration:**

   ```bash
   # Extract type definitions
   grep "interface.*Release" @lionralfs/discogs-client/types
   grep "ReleaseIO" discojs/models
   ```

2. **Use safe access patterns:**

   ```typescript
   // Before: assumed required
   const title = release.basic_information.title

   // After: handle optionality
   const title = release.basic_information.title ?? 'Unknown'
   ```

3. **Consider wrapper types:**
   ```typescript
   // Union of both library types for transition period
   type HybridRelease = LionralfsRelease | DiscojsRelease
   ```

**Detection:**

- TypeScript errors: "Object is possibly 'undefined'"
- Runtime errors: "Cannot read property 'X' of undefined"
- null reference exceptions in production

**Which phase:**

Phase 2 (type migration) - Surfaces when replacing type imports.

---

### Pitfall 6: Bottleneck Introduces Request Serialization

**What goes wrong:**

Adding Bottleneck rate limiting changes request execution from parallel to serialized within rate windows. This increases latency for multi-request operations.

**Example:**

```typescript
// Before: 10 requests fire in parallel
const results = await Promise.all(ids.map((id) => fetchRelease(id)))
// Total time: ~1 second (network latency)

// After: 10 requests queued through Bottleneck
const results = await Promise.all(ids.map((id) => fetchRelease(id)))
// Total time: ~10 seconds (serialized by limiter)
```

**Why it happens:**

Bottleneck enforces `maxConcurrent` limits. Default is often 1, meaning requests queue behind each other.

**Prevention:**

1. **Configure concurrency limits:**

   ```typescript
   const limiter = new Bottleneck({
     maxConcurrent: 5, // Allow 5 parallel requests
     minTime: 1000, // Min 1 second between batches
     reservoir: 60, // 60 requests per...
     reservoirRefreshAmount: 60,
     reservoirRefreshInterval: 60 * 1000 // ...minute
   })
   ```

2. **Batch operations differently:**

   ```typescript
   // Group by priority/category
   const critical = await limitedFetch(criticalIds)
   const optional = await limitedFetch(optionalIds)
   ```

3. **Add performance monitoring:**
   ```typescript
   const start = Date.now()
   await limitedFetch(...)
   console.log(`Request took ${Date.now() - start}ms`)
   ```

**Detection:**

- Suddenly slower API response times
- Requests that were ~1s now take 5-10s
- Network waterfall shows sequential instead of parallel

**Which phase:**

Phase 3 (rate limiting) - Appears when Bottleneck integration completes.

---

### Pitfall 7: Browser Compatibility Breaking

**What goes wrong:**

discojs defaults to `allowUnsafeHeaders: true`, which sets `Connection: 'close'` and other headers that browsers reject. Leads to CORS errors or blocked requests.

**Why it happens:**

discojs is designed for Node.js where these headers are allowed. Browser fetch() API rejects them for security.

**Prevention:**

1. **Always set allowUnsafeHeaders: false in browser:**

   ```typescript
   const client = new Discojs({
     consumerKey,
     consumerSecret,
     allowUnsafeHeaders: false // REQUIRED for browser
   })
   ```

2. **Environment detection:**

   ```typescript
   const isBrowser = typeof window !== 'undefined'
   const client = new Discojs({
     ...config,
     allowUnsafeHeaders: !isBrowser
   })
   ```

3. **Add browser integration test:** Run e2e test in actual browser environment

**Detection:**

- CORS errors in browser console
- "Refused to set unsafe header" errors
- Works in Node.js, fails in browser

**Which phase:**

Phase 1 (integration) - Must configure correctly from day one.

---

### Pitfall 8: Custom Type Deletion Without Full Verification

**What goes wrong:**

Deleting `src/types/discogs.ts` (738 lines) before verifying discojs types cover ALL used fields causes compilation cascade failures.

**Why it happens:**

Custom types may include fields not in discojs, or have different shapes for same entities. Eager deletion breaks all dependent code.

**Prevention:**

1. **Incremental migration strategy:**

   ```typescript
   // Phase 1: Add discojs types alongside custom types
   import { FolderReleasesResponse as DiscojsRelease } from 'discojs'
   import { DiscogsCollectionRelease as CustomRelease } from '@/types/discogs'

   // Phase 2: Gradually replace usage
   type Release = DiscojsRelease // Switch one type at a time

   // Phase 3: Delete custom types when zero references
   ```

2. **Create type compatibility matrix:**

   ```typescript
   // types/compatibility.ts
   type CompatibilityCheck = {
     custom: DiscogsCollectionRelease
     library: FolderReleasesResponse
   } & ({ custom: never } | { library: never }) // Force same shape
   ```

3. **Grep for all usages:**
   ```bash
   rg "DiscogsCollectionRelease|DiscogsPagination" --type ts
   ```

**Detection:**

- Hundreds of TypeScript errors after deletion
- "Cannot find name 'DiscogsX'" errors
- Build fails

**Which phase:**

Phase 4 (cleanup) - Only after all usages migrated and verified.

---

## Minor Pitfalls

### Pitfall 9: Retry-After Header Ignored

**What goes wrong:**

discojs doesn't implement special handling for 429 responses with `Retry-After` headers. Generic error handling may retry too aggressively.

**Prevention:**

1. **Add retry logic to facade:**

   ```typescript
   async function fetchWithRetry(fn: () => Promise<T>) {
     try {
       return await fn()
     } catch (err) {
       if (err.status === 429 && err.headers['retry-after']) {
         const delay = parseInt(err.headers['retry-after']) * 1000
         await sleep(delay)
         return await fn()
       }
       throw err
     }
   }
   ```

2. **Configure Bottleneck penalty:**
   ```typescript
   limiter.on('failed', (error, jobInfo) => {
     if (error.status === 429) {
       return 60000 // Retry after 1 minute
     }
   })
   ```

**Which phase:**

Phase 3 (rate limiting) - Enhancement after basic integration works.

---

### Pitfall 10: io-ts Dependency Confusion

**What goes wrong:**

Seeing io-ts validators in discojs types, developers assume runtime validation is active and rely on it for safety. In reality, discojs doesn't use io-ts at runtime - only for type derivation.

**Prevention:**

1. **Document clearly:** "discojs types are derived from io-ts but NOT validated at runtime"
2. **Add explicit validation if needed:**

   ```typescript
   import * as t from 'io-ts'
   import { FolderReleasesResponseIO } from 'discojs'

   const result = FolderReleasesResponseIO.decode(apiResponse)
   if (isLeft(result)) {
     // Handle validation error
   }
   ```

**Which phase:**

Phase 2 (type migration) - Clarify in documentation.

---

## Phase-Specific Warnings

| Phase   | Topic          | Likely Pitfall                        | Mitigation                                    |
| ------- | -------------- | ------------------------------------- | --------------------------------------------- |
| Phase 1 | Integration    | Token handoff fails between libraries | Add integration test for OAuth → discojs flow |
| Phase 1 | Integration    | Query param casing breaks searches    | Document limitation, manual conversion        |
| Phase 1 | Integration    | Browser headers cause CORS errors     | Set `allowUnsafeHeaders: false`               |
| Phase 2 | Type migration | Module augmentation overwrites types  | Always import before augmenting               |
| Phase 2 | Type migration | Type strictness mismatches            | Audit differences, use safe access            |
| Phase 3 | Rate limiting  | Requests serialize, latency increases | Configure concurrency limits                  |
| Phase 3 | Rate limiting  | Rate limit metadata lost              | Build facade to extract headers               |
| Phase 4 | Cleanup        | Delete types before full verification | Incremental migration, grep for usages        |

---

## Testing Checklist

Before declaring migration complete, verify:

- [ ] OAuth flow via @lionralfs → first discojs call succeeds
- [ ] Query params with snake_case names work correctly
- [ ] Rate limit metadata still returned in tRPC responses
- [ ] Module augmentation preserves all original fields
- [ ] Browser usage works without CORS errors
- [ ] Multi-request operations complete in reasonable time
- [ ] 429 errors trigger proper retry delays
- [ ] All DiscogsX custom type references replaced
- [ ] TypeScript compilation clean with no `as unknown as` casts
- [ ] Integration tests pass in both Node.js and browser

---

## Sources

### TypeScript Patterns

- [TypeScript Declaration Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)
- [TypeScript Module Augmentation Overwrites](https://futurestud.io/tutorials/typescript-module-augmentation-overwrites-declarations-instead-of-merging-them)
- [Module Augmentation in TypeScript](https://www.digitalocean.com/community/tutorials/typescript-module-augmentation)
- [TypeScript Breaking Changes](https://github.com/microsoft/TypeScript/wiki/Breaking-Changes)
- [Extending Library Types in TypeScript](https://www.index.dev/blog/extending-library-types-in-typescript)

### API Client Integration

- [API Design Patterns](https://www.netguru.com/blog/api-design-patterns)
- [SDK Development Analysis](https://vineeth.io/posts/sdk-development)
- [API Integration Patterns](https://dzone.com/refcardz/api-integration-patterns)
- [Type Safe API Clients](https://dev.to/nazeelashraf/writing-type-safe-api-clients-in-typescript-1j92)

### Rate Limiting

- [Bottleneck Rate Limiter Guide](https://dev.to/arifszn/prevent-api-overload-a-comprehensive-guide-to-rate-limiting-with-bottleneck-c2p)
- [API Rate Limiting 2026](https://www.levo.ai/resources/blogs/api-rate-limiting-guide-2026)
- [Rate Limiting at Scale](https://www.gravitee.io/blog/rate-limiting-apis-scale-patterns-strategies)
- [Handling Rate Limits](https://www.ayrshare.com/complete-guide-to-handling-rate-limits-prevent-429-errors/)
- [Bottleneck npm](https://www.npmjs.com/package/bottleneck)

### OAuth Token Sharing

- [oauth-1.0a npm](https://www.npmjs.com/package/oauth-1.0a)
- [OAuth 1.0 Specification](https://oauth.net/1/)

### Project-Specific

- [VinylDeck Discogs API Types Research](docs/research/2026-01-28-discogs-api-types.md)
- [discojs GitHub](https://github.com/aknorw/discojs)
- [discojs Issues](https://github.com/aknorw/discojs/issues)

---

## Confidence Assessment

| Area                     | Level  | Reason                                                |
| ------------------------ | ------ | ----------------------------------------------------- |
| Query param bug          | HIGH   | Verified in discojs source code (fetch.ts:259-268)    |
| Rate limit metadata      | HIGH   | Verified in discojs implementation (no exposure)      |
| Token handoff            | MEDIUM | OAuth 1.0a standard, but library differences possible |
| Module augmentation      | HIGH   | Documented TypeScript behavior, verified in docs      |
| Type strictness          | MEDIUM | Depends on specific field differences, needs audit    |
| Bottleneck serialization | HIGH   | Standard Bottleneck behavior, documented              |
| Browser compatibility    | HIGH   | Verified in discojs source (fetch.ts:122-128)         |
| Custom type deletion     | HIGH   | Standard refactoring risk                             |

---

_Research complete. Ready for roadmap integration._
