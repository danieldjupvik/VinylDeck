---
phase: 04-type-system-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - bun.lockb
  - src/types/discogs.ts
  - src/types/discogs-legacy.ts
  - src/types/discogs/oauth.ts
  - src/types/discogs/augment.ts
  - src/types/discogs/index.ts
autonomous: true

must_haves:
  truths:
    - 'discojs is installed as a dependency'
    - 'Old discogs.ts renamed to discogs-legacy.ts to avoid module resolution conflict'
    - 'OAuth types are extracted from @lionralfs via ReturnType inference'
    - 'Missing User fields (avatar_url, banner_url) are augmented onto discojs types'
    - 'All Discogs types are accessible from single import path @/types/discogs'
  artifacts:
    - path: 'src/types/discogs-legacy.ts'
      provides: 'Renamed old types file (deletion deferred to Phase 8)'
      min_lines: 100
    - path: 'src/types/discogs/oauth.ts'
      provides: 'OAuth type extraction from @lionralfs'
      exports:
        [
          'RequestTokenResult',
          'AccessTokenResult',
          'OAuthTokens',
          'OAuthRequestTokens'
        ]
    - path: 'src/types/discogs/augment.ts'
      provides: 'Module augmentation for missing discojs fields'
      contains: "declare module 'discojs/lib/types'"
    - path: 'src/types/discogs/index.ts'
      provides: 'Barrel export for all Discogs types'
      exports:
        [
          'User',
          'Identity',
          'CollectionRelease',
          'BasicInformation',
          'Pagination'
        ]
  key_links:
    - from: 'src/types/discogs/index.ts'
      to: 'src/types/discogs/augment.ts'
      via: 'side-effect import'
      pattern: "import './augment"
    - from: 'src/types/discogs/index.ts'
      to: 'discojs/lib/types'
      via: 'type re-export'
      pattern: "from 'discojs/lib/types"
---

<objective>
Create discojs-based type system with module augmentation and OAuth type extraction.

Purpose: Establish type foundation that auto-syncs with discojs updates and provides type-safe OAuth types extracted from @lionralfs.
Output: New `src/types/discogs/` directory with barrel export, augmentation, and OAuth types. Old `discogs.ts` renamed to `discogs-legacy.ts` to avoid module resolution conflict.
</objective>

<execution_context>
@/Users/danieldjupvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danieldjupvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-type-system-foundation/04-CONTEXT.md
@.planning/phases/04-type-system-foundation/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install discojs and verify type exports</name>
  <files>
    package.json
    bun.lockb
  </files>
  <action>
1. Install discojs:
   ```bash
   bun add discojs
   ```

2. **VERIFICATION STEP - Locate discojs type exports:**
   Before writing any code, verify where discojs actually exports its types:

   ```bash
   # Check main export
   cat node_modules/discojs/lib/index.d.ts | head -30

   # Check types location
   ls node_modules/discojs/lib/types/
   cat node_modules/discojs/lib/types/index.d.ts | head -50
   ```

   Expected: Types are exported from `discojs/lib/types` (not main `discojs` module).
   If types are at a different path, adjust all subsequent imports accordingly.

3. **VERIFICATION STEP - Check for existing User fields in discojs:**
   Before writing augmentation, verify avatar_url/banner_url don't already exist:

   ```bash
   grep -n "avatar_url\|banner_url" node_modules/discojs/lib/types/*.d.ts
   ```

   If fields already exist in discojs:
   - Check if they're `string | null` vs `string | undefined`
   - If they match our needs, skip augmentation for those fields
   - If they differ (e.g., `string | null` vs `string | undefined`), document but don't override

4. **VERIFICATION STEP - Check DiscogsOAuth class pattern:**
   Verify the OAuth extraction pattern works:

   ```bash
   cat node_modules/@lionralfs/discogs-client/types/oauth.d.ts
   ```

   Confirm DiscogsOAuth is exported as a class (not just type), so `InstanceType<typeof DiscogsOAuth>` works.
   If it's a type-only export, adjust to use direct type reference.

  </action>
  <verify>
    - `bun install` completes without errors
    - discojs appears in package.json dependencies
    - Type export paths are documented
    - User field status documented (exists in discojs or needs augmentation)
    - OAuth extraction pattern verified
  </verify>
  <done>
    - discojs installed
    - Clear understanding of type export paths
    - Clear understanding of what needs augmentation vs what discojs already provides
  </done>
</task>

<task type="auto">
  <name>Task 2: Rename old types file and create type infrastructure</name>
  <files>
    src/types/discogs.ts
    src/types/discogs-legacy.ts
    src/types/discogs/oauth.ts
    src/types/discogs/augment.ts
    src/types/discogs/index.ts
  </files>
  <action>
1. **CRITICAL - Rename old types file to avoid module resolution conflict:**
   ```bash
   git mv src/types/discogs.ts src/types/discogs-legacy.ts
   ```

WHY: With both `src/types/discogs.ts` (file) and `src/types/discogs/index.ts` (directory),
TypeScript resolves `@/types/discogs` to the FILE, not the directory. Renaming the file
ensures the barrel at `src/types/discogs/index.ts` is resolved correctly.

2. Create `src/types/discogs/oauth.ts`:
   - Use type-only import to avoid pulling @lionralfs into client bundles:
     ```typescript
     import type { DiscogsOAuth } from '@lionralfs/discogs-client'
     ```
   - Extract RequestTokenResult and AccessTokenResult using ReturnType inference:
     ```typescript
     type OAuthInstance = InstanceType<typeof DiscogsOAuth>
     export type RequestTokenResult = Awaited<
       ReturnType<OAuthInstance['getRequestToken']>
     >
     export type AccessTokenResult = Awaited<
       ReturnType<OAuthInstance['getAccessToken']>
     >
     ```
   - Include OAuthTokens interface (app-level token storage, same as current):
     ```typescript
     export interface OAuthTokens {
       accessToken: string
       accessTokenSecret: string
     }
     ```
   - Include OAuthRequestTokens interface (temporary session tokens):
     ```typescript
     export interface OAuthRequestTokens {
       requestToken: string
       requestTokenSecret: string
     }
     ```
   - Add JSDoc comments documenting source of each type

3. Create `src/types/discogs/augment.ts`:
   - Import 'discojs' to trigger module resolution (side-effect)
   - Use `declare module 'discojs/lib/types'` to augment (NOT `'discojs'` - research confirms types are at this path)
   - Add avatar_url and banner_url as optional strings (only if verification showed they're missing):

     ```typescript
     import 'discojs'

     declare module 'discojs/lib/types' {
       interface User {
         /** @endpoint GET /users/{username} @optional Users without avatars */
         avatar_url?: string
         /** @endpoint GET /users/{username} @optional Users without banners */
         banner_url?: string
       }
     }
     ```

   - Include JSDoc explaining why each field is augmented

4. Create `src/types/discogs/index.ts`:
   - Import augmentation first (side-effect): `import './augment.js'`
   - Re-export discojs types from correct path with explicit named exports:
     ```typescript
     export type {
       User,
       Identity,
       BasicInformation,
       Pagination
     } from 'discojs/lib/types'
     ```
   - Re-export CollectionRelease (check discojs exports for exact name)
   - Re-export application-specific types that will stay in this codebase:
     - CollectionSortKey, CollectionSortOrder, DiscogsCollectionSortKey (client-side sort enums)
     - DiscogsFormat (if not in discojs)
   - Re-export OAuth types with type-only export to avoid runtime imports:
     ```typescript
     export type {
       RequestTokenResult,
       AccessTokenResult,
       OAuthTokens,
       OAuthRequestTokens
     } from './oauth.js'
     ```

   **IMPORTANT:** Do NOT use `export * from './oauth.js'` - this could pull @lionralfs runtime code
   into client bundles. Use explicit `export type { ... }` for tree-shaking safety.

NOTE: Check discojs type exports carefully. The library may use different names than current codebase (e.g., `CollectionItem` vs `DiscogsCollectionRelease`). Map appropriately with type aliases if needed:

```typescript
export type { CollectionItem as DiscogsCollectionRelease } from 'discojs/lib/types'
```

  </action>
  <verify>
    - `ls src/types/discogs/` shows oauth.ts, augment.ts, index.ts
    - `ls src/types/discogs.ts` fails (file renamed)
    - `ls src/types/discogs-legacy.ts` succeeds
    - TypeScript compiles the new files: `bunx tsc --noEmit src/types/discogs/index.ts`
  </verify>
  <done>
    - Old discogs.ts renamed to discogs-legacy.ts
    - Three new files exist in src/types/discogs/
    - All types are accessible via import from the barrel file
    - Module resolution now correctly resolves @/types/discogs to the barrel
  </done>
</task>

<task type="auto">
  <name>Task 3: Migrate all type imports to new barrel</name>
  <files>
    src/providers/auth-context.ts
    src/lib/oauth-session.ts
    src/hooks/use-collection.ts
    src/hooks/use-collection-sync.ts
    src/components/collection/vinyl-grid.tsx
    src/components/collection/vinyl-card.tsx
    src/components/collection/vinyl-table.tsx
    src/components/collection/collection-toolbar.tsx
    src/server/trpc/routers/discogs.ts
  </files>
  <action>
1. Update client-side imports (use @/ alias):
   - All files currently importing from `'@/types/discogs'` will now resolve to the barrel
   - No path changes needed for client code since the barrel is at the same logical path
   - BUT: Any file importing from `'@/types/discogs'` that now gets a TS error means a type
     name changed. Fix by updating the type name or adding an alias in the barrel.

2. Update server-side imports (use relative paths with .js extension per Vercel requirements):
   - `src/server/trpc/routers/discogs.ts`: Change `from '../../../types/discogs.js'` to `from '../../../types/discogs/index.js'`

3. Type name mapping (if discojs uses different names):
   - If discojs exports `CollectionItem`, update barrel to alias: `export type { CollectionItem as DiscogsCollectionRelease }`
   - If discojs exports `Release` for collection items, same approach
   - Consumer code should NOT change type names - barrel handles mapping

4. Handle types that stay local (not from discojs):
   - CollectionSortKey, CollectionSortOrder, DiscogsCollectionSortKey - these are app-specific sort enums
   - Either define in barrel file OR copy from discogs-legacy.ts
   - DiscogsFormat - check if discojs has Format type; if not, copy from discogs-legacy.ts

5. Run full TypeScript check:

   ```bash
   bunx tsc --noEmit
   ```

   Fix any type errors that surface.

6. Run Vercel build to catch server-side issues:
   ```bash
   vercel build
   ```
   (or `bunx tsc -b` if vercel CLI not set up)
   </action>
   <verify> - `bunx tsc --noEmit` passes with no errors - `bun run build` succeeds - `bun run lint` passes
   </verify>
   <done> - All imports updated to use new barrel path - No TypeScript errors in codebase - Build succeeds locally
   </done>
   </task>

</tasks>

<verification>
Run the following to verify phase completion:

```bash
# TypeScript compilation
bunx tsc --noEmit

# Full build (includes Vite + type checking)
bun run build

# Lint check
bun run lint

# Verify old file is renamed (not at old location)
test ! -f src/types/discogs.ts && echo "PASS: old file removed" || echo "FAIL: old file still exists"

# Verify new barrel exists
test -d src/types/discogs && echo "PASS: barrel directory exists" || echo "FAIL: no barrel directory"
```

All commands should pass without errors.
</verification>

<success_criteria>

- discojs installed as dependency
- src/types/discogs.ts renamed to src/types/discogs-legacy.ts (deletion deferred to Phase 8)
- src/types/discogs/ directory exists with oauth.ts, augment.ts, index.ts
- Module augmentation targets 'discojs/lib/types' (not 'discojs')
- OAuth types use type-only exports (no runtime @lionralfs in client bundles)
- All codebase imports use new type paths
- TypeScript compiles without errors
- Build succeeds
  </success_criteria>

<output>
After completion, create `.planning/phases/04-type-system-foundation/04-01-SUMMARY.md`
</output>
