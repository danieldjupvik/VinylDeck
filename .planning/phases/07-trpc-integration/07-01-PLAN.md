---
phase: 07-trpc-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/trpc/error-mapper.ts
  - src/server/discogs/client.ts
  - src/server/discogs/index.ts
  - src/server/trpc/routers/oauth.ts
autonomous: true

must_haves:
  truths:
    - 'Error mapper converts facade errors to TRPCError with correct codes'
    - 'OAuth router uses facade client instead of direct @lionralfs import'
    - 'OAuth router returns flat facade responses (no wrapping)'
    - 'DataClient facade exposes getCollectionMetadata()'
  artifacts:
    - path: 'src/server/trpc/error-mapper.ts'
      provides: 'Facade-to-tRPC error mapping function'
      exports: ['mapFacadeErrorToTRPC']
    - path: 'src/server/trpc/routers/oauth.ts'
      provides: 'OAuth router using facade client'
      contains: 'createDiscogsClient'
    - path: 'src/server/discogs/client.ts'
      provides: 'DataClient with getCollectionMetadata method'
      contains: 'getCollectionMetadata'
  key_links:
    - from: 'src/server/trpc/error-mapper.ts'
      to: 'src/server/discogs/index.ts'
      via: 'import error classes'
      pattern: 'import.*DiscogsAuthError.*DiscogsApiError.*DiscogsRateLimitError'
    - from: 'src/server/trpc/routers/oauth.ts'
      to: 'src/server/discogs/index.ts'
      via: 'import createDiscogsClient'
      pattern: 'import.*createDiscogsClient.*from.*discogs/index'
    - from: 'src/server/trpc/routers/oauth.ts'
      to: 'src/server/trpc/error-mapper.ts'
      via: 'import error mapper'
      pattern: 'import.*mapFacadeErrorToTRPC.*from.*error-mapper'
---

<objective>
Create the facade-to-tRPC error mapper, add getCollectionMetadata to the DataClient facade, and migrate the OAuth router to use the facade.

Purpose: Establishes the error bridging infrastructure and proves the migration pattern with the simpler OAuth router before tackling the data-heavy Discogs router.
Output: Error mapper utility, expanded DataClient, fully migrated OAuth router.
</objective>

<execution_context>
@/Users/danieldjupvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danieldjupvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-trpc-integration/07-CONTEXT.md
@.planning/phases/07-trpc-integration/07-RESEARCH.md
@src/server/discogs/index.ts
@src/server/discogs/errors.ts
@src/server/discogs/client.ts
@src/server/discogs/oauth.ts
@src/server/discogs/retry.ts
@src/server/trpc/error-utils.ts
@src/server/trpc/routers/oauth.ts
@src/lib/errors.ts
@src/types/discogs/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error mapper and add getCollectionMetadata to facade</name>
  <files>
    src/server/trpc/error-mapper.ts
    src/server/discogs/client.ts
    src/server/discogs/index.ts
  </files>
  <action>
**Error mapper (`src/server/trpc/error-mapper.ts`):**

Create a `mapFacadeErrorToTRPC(error: unknown, operation: string): never` function. Per user decision, this replaces `handleDiscogsError` from `error-utils.ts`.

Import `DiscogsAuthError`, `DiscogsApiError`, `DiscogsRateLimitError` from `../../discogs/index.js` (the facade). Import `TRPCError` from `@trpc/server`. Import `RateLimitError` from `../../lib/errors.js` (the actual class used by retry.ts).

NOTE: The facade re-exports `RateLimitError` as `DiscogsRateLimitError`, but `retry.ts` throws the original `RateLimitError` from `src/lib/errors.ts`. The error mapper must handle BOTH — check `instanceof RateLimitError` (from `src/lib/errors.ts`) since that's what actually gets thrown at runtime. Import it directly from `../../lib/errors.js`.

Mapping rules per user decision:

- Re-throw TRPCError instances as-is (no double-wrapping)
- `DiscogsAuthError` -> `UNAUTHORIZED` (if statusCode 401) or `FORBIDDEN` (if 403)
- `RateLimitError` -> `TOO_MANY_REQUESTS` with message `Rate limit exceeded. Retry after ${Math.ceil(error.retryAfterMs / 1000)}s`
- `DiscogsApiError` -> status-based: 400=BAD_REQUEST, 404=NOT_FOUND, else INTERNAL_SERVER_ERROR
- Unknown errors -> `INTERNAL_SERVER_ERROR` with `Failed to ${operation}: ${message}`
- Always preserve original error as `cause`

Use `.js` extension on all relative imports (Vercel Serverless requirement). No `@/` aliases.

Add TSDoc: `@param error`, `@param operation`, `@throws {TRPCError}`.

**getCollectionMetadata in DataClient (`src/server/discogs/client.ts`):**

Add `getCollectionMetadata(username: string): Promise<{ totalCount: number }>` to the `DataClient` interface.

Implement it in `createDataClient` return object. It should:

1. Require tokens (throw `DiscogsAuthError` if not present, same pattern as other methods)
2. Call `wrapCall('getCollectionMetadata', ...)` wrapping `client.listItemsInFolderForUser(username, 0, undefined, { page: 1, perPage: 1 })`
3. Extract `pagination.items` from the response and return `{ totalCount: pagination.items }`

This hides the perPage=1 trick inside the facade per user decision.

**Update facade index (`src/server/discogs/index.ts`):**

No changes needed — `DataClient` type is already re-exported. But verify the export is there.
</action>
<verify>
Run `bunx tsc --noEmit` — no type errors in the new/modified files. Verify `error-mapper.ts` exports `mapFacadeErrorToTRPC`. Verify `DataClient` interface includes `getCollectionMetadata`.
</verify>
<done>
Error mapper function exists and handles all facade error types. DataClient interface and implementation include getCollectionMetadata that returns `{ totalCount: number }`.
</done>
</task>

<task type="auto">
  <name>Task 2: Migrate OAuth router to facade</name>
  <files>
    src/server/trpc/routers/oauth.ts
  </files>
  <action>
Rewrite the OAuth router to use the facade instead of direct `@lionralfs/discogs-client` import. Per user decision, all routers import only from the facade.

**Remove:**

- `import { DiscogsOAuth } from '@lionralfs/discogs-client'`
- `import { handleDiscogsError } from '../error-utils.js'`
- The `getDiscogsOAuth()` helper function entirely
- The `CONSUMER_KEY` and `CONSUMER_SECRET` constants (facade handles credentials)
- The `process.env` declare block for consumer key/secret (keep ALLOWED_CALLBACK_ORIGINS and VERCEL_URL)

**Add:**

- `import { createDiscogsClient } from '../../discogs/index.js'`
- `import { mapFacadeErrorToTRPC } from '../error-mapper.js'`

**Keep unchanged:**

- `getAllowedCallbackOrigins()` function and its `process.env` declare for ALLOWED_CALLBACK_ORIGINS and VERCEL_URL
- `validateCallbackUrl()` function (callback URL validation stays in router per user decision — deployment security)
- Zod input schemas (tokens as Zod params per user decision)

**getRequestToken procedure:**

- Replace `const oauth = getDiscogsOAuth()` with `const client = createDiscogsClient()`
- In try block: `return await client.oauth.getRequestToken(input.callbackUrl)` — the facade already validates token/tokenSecret and returns `{ requestToken, requestTokenSecret, authorizeUrl }`, so remove the manual null checks for `response.token`/`response.tokenSecret` and the manual object construction
- In catch: replace `handleDiscogsError(error, 'get request token')` with `mapFacadeErrorToTRPC(error, 'get request token')`

**getAccessToken procedure:**

- Replace `const oauth = getDiscogsOAuth()` with `const client = createDiscogsClient()`
- In try block: `return await client.oauth.getAccessToken(input.requestToken, input.requestTokenSecret, input.verifier)` — facade already returns `{ accessToken, accessTokenSecret }`, so remove manual null checks and object construction
- In catch: replace with `mapFacadeErrorToTRPC(error, 'get access token')`

Per user decision: flat returns, no wrapping in named keys, full type pass-through from facade.
</action>
<verify>
Run `bunx tsc --noEmit` — no type errors. Grep `oauth.ts` for `@lionralfs` — should find zero matches. Grep for `handleDiscogsError` — zero matches. Grep for `createDiscogsClient` — should find the import.
</verify>
<done>
OAuth router imports only from facade and error-mapper. No direct library imports. Flat responses returned. Callback URL validation preserved.
</done>
</task>

</tasks>

<verification>
- `bunx tsc --noEmit` passes with no errors
- `bun run lint` passes
- `grep -r "handleDiscogsError" src/server/trpc/routers/oauth.ts` returns empty
- `grep -r "@lionralfs" src/server/trpc/routers/oauth.ts` returns empty
- `grep "mapFacadeErrorToTRPC" src/server/trpc/error-mapper.ts` finds the export
- `grep "getCollectionMetadata" src/server/discogs/client.ts` finds the method
</verification>

<success_criteria>

- Error mapper exists at src/server/trpc/error-mapper.ts with correct facade error -> TRPCError mapping
- DataClient.getCollectionMetadata() exists and hides the perPage=1 trick
- OAuth router uses facade exclusively (zero direct library imports)
- OAuth router returns flat responses from facade
- TypeScript compiles without errors
  </success_criteria>

<output>
After completion, create `.planning/phases/07-trpc-integration/07-01-SUMMARY.md`
</output>
