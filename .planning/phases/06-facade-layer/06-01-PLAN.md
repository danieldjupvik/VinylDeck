---
phase: 06-facade-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/discogs/errors.ts
  - src/server/discogs/oauth.ts
  - src/server/discogs/client.ts
  - src/server/discogs/index.ts
autonomous: true

must_haves:
  truths:
    - 'createDiscogsClient() returns client with oauth and data namespaces'
    - 'OAuth operations (getRequestToken, getAccessToken) route through @lionralfs wrapper'
    - 'Data operations (getIdentity, listItemsInFolderForUser, getProfileForUser) route through discojs wrapper with retry'
    - 'All errors thrown by facade are unified types (DiscogsApiError, DiscogsAuthError, DiscogsRateLimitError)'
    - 'Client works with or without authentication tokens'
  artifacts:
    - path: 'src/server/discogs/errors.ts'
      provides: 'Unified facade error types'
      exports: ['DiscogsApiError', 'DiscogsAuthError', 'DiscogsRateLimitError']
    - path: 'src/server/discogs/oauth.ts'
      provides: 'OAuth wrapper using @lionralfs'
      exports: ['createOAuthClient']
    - path: 'src/server/discogs/client.ts'
      provides: 'Data client wrapper using discojs with retry'
      exports: ['createDataClient']
    - path: 'src/server/discogs/index.ts'
      provides: 'Facade entry point'
      exports: ['createDiscogsClient', 'DiscogsClient', 'OAuthTokens']
  key_links:
    - from: 'src/server/discogs/index.ts'
      to: 'src/server/discogs/oauth.ts'
      via: 'createOAuthClient import'
      pattern: 'import.*createOAuthClient.*from.*oauth'
    - from: 'src/server/discogs/index.ts'
      to: 'src/server/discogs/client.ts'
      via: 'createDataClient import'
      pattern: 'import.*createDataClient.*from.*client'
    - from: 'src/server/discogs/client.ts'
      to: 'src/server/discogs/retry.ts'
      via: 'withRateLimitRetry wrapper'
      pattern: 'withRateLimitRetry'
    - from: 'src/server/discogs/oauth.ts'
      to: '@lionralfs/discogs-client'
      via: 'DiscogsOAuth import'
      pattern: 'import.*DiscogsOAuth.*from.*@lionralfs'
    - from: 'src/server/discogs/client.ts'
      to: 'discojs'
      via: 'Discojs import'
      pattern: 'import.*Discojs.*from.*discojs'
---

<objective>
Create facade layer that hides dual-library complexity behind single entry point.

Purpose: Provide unified API surface for tRPC routers to consume without knowing about @lionralfs vs discojs split. Unified error handling and optional auth support.

Output:

- `createDiscogsClient()` factory function
- `client.oauth.*` namespace for OAuth operations (@lionralfs)
- `client.data.*` namespace for data operations (discojs)
- Unified error types with Error.cause preservation
  </objective>

<execution_context>
@/Users/danieldjupvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danieldjupvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-facade-layer/06-CONTEXT.md
@.planning/phases/06-facade-layer/06-RESEARCH.md
@.planning/phases/05-rate-limiting/05-01-SUMMARY.md

# Existing implementations to use

@src/server/discogs/retry.ts
@src/server/discogs/rate-state.ts
@src/types/discogs/index.ts
@src/types/discogs/oauth.ts
@src/lib/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unified errors and OAuth wrapper</name>
  <files>
    src/server/discogs/errors.ts
    src/server/discogs/oauth.ts
  </files>
  <action>
Create `src/server/discogs/errors.ts`:
- `DiscogsApiError` class extending Error with statusCode and originalError properties
- `DiscogsAuthError` class extending Error with statusCode (401 | 403) and originalError
- Both use ES2022 Error.cause for stack trace preservation
- Re-export RateLimitError from retry.ts as `DiscogsRateLimitError` for facade API consistency

Create `src/server/discogs/oauth.ts`:

- `createOAuthClient()` factory function returning OAuth operations object
- Uses `DiscogsOAuth` from @lionralfs/discogs-client
- Methods: `getRequestToken(callbackUrl)` and `getAccessToken(requestToken, requestTokenSecret, verifier)`
- Wrap errors in DiscogsApiError with cause preservation
- Read consumer key/secret from process.env (VITE_DISCOGS_CONSUMER_KEY, DISCOGS_CONSUMER_SECRET)
- Throw DiscogsApiError if credentials missing

Follow patterns from RESEARCH.md examples. Use .js extensions on all relative imports for Vercel compatibility.
</action>
<verify>
TypeScript compiles: `bunx tsc --noEmit`
Files exist with correct exports: `grep -l "export.*DiscogsApiError\|export.*createOAuthClient" src/server/discogs/*.ts`
</verify>
<done>
errors.ts exports DiscogsApiError, DiscogsAuthError, DiscogsRateLimitError
oauth.ts exports createOAuthClient with getRequestToken and getAccessToken methods
</done>
</task>

<task type="auto">
  <name>Task 2: Create data client wrapper and facade entry point</name>
  <files>
    src/server/discogs/client.ts
    src/server/discogs/index.ts
  </files>
  <action>
Create `src/server/discogs/client.ts`:
- `createDataClient(tokens?: OAuthTokens)` factory function
- Uses `Discojs` from discojs

**CRITICAL: discojs OAuth 1.0a config (NOT userToken)**
When tokens provided, configure discojs with OAuth 1.0a credentials:

```typescript
new Discojs({
  consumerKey: process.env.VITE_DISCOGS_CONSUMER_KEY,
  consumerSecret: process.env.DISCOGS_CONSUMER_SECRET,
  oAuthToken: tokens.accessToken,
  oAuthTokenSecret: tokens.accessTokenSecret,
  userAgent: `VinylDeck/${APP_VERSION}`
})
```

Do NOT use `userToken` - that's for personal access tokens only.

- Wrap all calls with `withRateLimitRetry` from retry.ts
- Methods (use ACTUAL discojs method names):
  - `getIdentity()` - requires auth, throws DiscogsAuthError if no tokens. Maps to `client.getIdentity()`
  - `getCollectionReleases(username, folderId?, sort?, pagination?)` - requires auth. Maps to `client.listItemsInFolderForUser(username, folderId, sort, pagination)`
  - `getUserProfile(username)` - requires auth. Maps to `client.getProfileForUser(username)`
- Error handling: catch DiscogsError, check statusCode for 401/403 -> DiscogsAuthError, else DiscogsApiError
- Pass camelCase params to discojs (no conversion needed, discojs handles internally)

Create `src/server/discogs/index.ts`:

- `createDiscogsClient(tokens?: OAuthTokens)` factory returning `{ oauth, data }` namespaces
- Import/call createOAuthClient and createDataClient
- Re-export all error types from errors.ts
- Re-export rate state utilities from rate-state.ts
- Export OAuthTokens type from types/discogs/oauth.ts
- Export DiscogsClient interface with oauth and data properties

Follow grouped namespace pattern from RESEARCH.md. Use .js extensions on all relative imports.
</action>
<verify>
TypeScript compiles: `bunx tsc --noEmit`
Vercel build works: `vercel build 2>&1 | head -50`
Facade exports createDiscogsClient: `grep "export.*createDiscogsClient" src/server/discogs/index.ts`
</verify>
<done>
client.ts exports createDataClient with getIdentity, getCollectionReleases (wraps listItemsInFolderForUser), getUserProfile (wraps getProfileForUser)
discojs configured with OAuth 1.0a (consumerKey/consumerSecret/oAuthToken/oAuthTokenSecret), NOT userToken
index.ts exports createDiscogsClient returning { oauth, data } namespaces
All error types and rate state utilities re-exported from facade entry point
</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `bunx tsc --noEmit`
2. Vercel build passes: `vercel build`
3. Facade pattern verified:
   - `createDiscogsClient()` returns object with `oauth` and `data` properties
   - OAuth methods accessible via `client.oauth.getRequestToken()`
   - Data methods accessible via `client.data.getIdentity()`
4. Error types unified:
   - All facade errors extend Error with cause
   - Auth errors (401/403) throw DiscogsAuthError
   - Rate limit errors rethrow RateLimitError from retry.ts
5. Optional auth works:
   - `createDiscogsClient()` without tokens creates client
   - Auth-required methods throw DiscogsAuthError when called without tokens
</verification>

<success_criteria>

- createDiscogsClient() factory returns client with oauth and data namespaces
- OAuth operations route through @lionralfs wrapper
- Data operations route through discojs with rate limit retry
- All errors are unified facade types with Error.cause
- Client accepts optional tokens parameter
- TypeScript and Vercel builds pass
  </success_criteria>

<output>
After completion, create `.planning/phases/06-facade-layer/06-01-SUMMARY.md`
</output>
