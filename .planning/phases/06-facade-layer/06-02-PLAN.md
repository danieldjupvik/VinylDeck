---
phase: 06-facade-layer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/discogs/client.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - 'getUserProfile returns User type with banner_url property accessible'
    - 'getIdentity returns Identity type from src/types/discogs'
    - 'getCollectionReleases returns CollectionResponse type from src/types/discogs'
  artifacts:
    - path: 'src/server/discogs/client.ts'
      provides: 'DataClient interface with extended types'
      contains: 'import type { User, Identity, CollectionResponse }'
  key_links:
    - from: 'src/server/discogs/client.ts'
      to: 'src/types/discogs/index.ts'
      via: 'type imports'
      pattern: 'import type.*User.*Identity.*CollectionResponse'
---

<objective>
Fix DataClient interface to return extended types from src/types/discogs instead of raw discojs ReturnType extractions.

Purpose: UAT Test 5 failed - getUserProfile returns raw discojs type without banner_url. Our extended User type in src/types/discogs/index.ts includes banner_url but the facade doesn't use it.

Output: DataClient interface using User, Identity, and CollectionResponse types from our type barrel.
</objective>

<execution_context>
@/Users/danieldjupvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danieldjupvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src/server/discogs/client.ts
@src/types/discogs/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update DataClient interface to use extended types</name>
  <files>src/server/discogs/client.ts</files>
  <action>
1. Add imports at top of file (after existing imports):
   ```typescript
   import type { User, Identity, CollectionResponse } from '../../types/discogs/index.js'
   ```

2. Update DataClient interface (lines 54-69) to use imported types:
   ```typescript
   export interface DataClient {
     getIdentity(): Promise<Identity>
     getCollectionReleases(
       username: string,
       folderId?: number,
       options?: {
         page?: number | undefined
         perPage?: number | undefined
         sort?: UserSortEnum | undefined
         sortOrder?: SortOrdersEnum | undefined
       }
     ): Promise<CollectionResponse>
     getUserProfile(username: string): Promise<User>
   }
   ```

The method implementations remain unchanged - they still call discojs methods. We're only typing the interface with our extended types that include fields like banner_url.

Note: The runtime return values from discojs already include banner_url when present in the API response - we're just making TypeScript aware of it through our extended types.
</action>
<verify>
Run `bun run lint` and `vercel build` to confirm no TypeScript errors. Hover over getUserProfile return type in IDE should show User with banner_url property.
</verify>
<done>
DataClient.getUserProfile returns User type (with banner_url), DataClient.getIdentity returns Identity, DataClient.getCollectionReleases returns CollectionResponse. All from src/types/discogs barrel.
</done>
</task>

</tasks>

<verification>
1. `bun run lint` passes
2. `vercel build` completes without TypeScript errors
3. In IDE: hover over `client.data.getUserProfile()` shows return type `Promise<User>` with banner_url property visible
</verification>

<success_criteria>

- DataClient interface imports User, Identity, CollectionResponse from src/types/discogs
- getUserProfile returns Promise<User> (includes banner_url)
- getIdentity returns Promise<Identity>
- getCollectionReleases returns Promise<CollectionResponse>
- No TypeScript errors in lint or Vercel build
  </success_criteria>

<output>
After completion, create `.planning/phases/06-facade-layer/06-02-SUMMARY.md`
</output>
