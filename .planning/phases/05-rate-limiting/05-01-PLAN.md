---
phase: 05-rate-limiting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/discogs/retry.ts
  - src/server/discogs/rate-state.ts
  - src/lib/errors.ts
autonomous: true

must_haves:
  truths:
    - '429 errors from discojs are caught and retried with exponential backoff'
    - 'RateLimitError is thrown after retries exhausted with remaining wait time'
    - 'Rate limit state is trackable from API responses'
  artifacts:
    - path: 'src/server/discogs/retry.ts'
      provides: 'Retry wrapper with exponential backoff and jitter'
      exports:
        [
          'withRateLimitRetry',
          'isRateLimitError',
          'calculateBackoff',
          'RateLimitError'
        ]
    - path: 'src/server/discogs/rate-state.ts'
      provides: 'Rate limit state tracking infrastructure'
      exports:
        [
          'RateLimitState',
          'rateLimitState',
          'updateRateLimitState',
          'getRateLimitState'
        ]
    - path: 'src/lib/errors.ts'
      provides: 'Re-export of RateLimitError for client consumption'
      contains: 'RateLimitError'
  key_links:
    - from: 'src/server/discogs/retry.ts'
      to: 'discojs.DiscogsError'
      via: 'import and instanceof check'
      pattern: 'instanceof DiscogsError'
    - from: 'src/lib/errors.ts'
      to: 'src/server/discogs/retry.ts'
      via: 're-export'
      pattern: 'export.*RateLimitError'
---

<objective>
Create rate limiting infrastructure for 429 error handling and rate state exposure.

Purpose: Enable reactive recovery from Discogs API rate limits and provide observability for downstream consumers (tRPC handlers, UI). discojs already handles proactive throttling via built-in Bottleneck — this plan adds the missing reactive layer.

Output: Retry wrapper module, rate state tracking module, RateLimitError type exported for client use.
</objective>

<execution_context>
@/Users/danieldjupvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danieldjupvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-rate-limiting/05-CONTEXT.md
@.planning/phases/05-rate-limiting/05-RESEARCH.md

# Existing codebase reference

@src/lib/errors.ts
@src/lib/constants.ts
@src/api/rate-limiter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create retry infrastructure with RateLimitError</name>
  <files>src/server/discogs/retry.ts</files>
  <action>
Create `src/server/discogs/retry.ts` with:

1. **RateLimitError class:**
   - Extends Error with `name = 'RateLimitError'`
   - Properties: `readonly retryAfterMs: number`, `readonly statusCode = 429`
   - Constructor takes `retryAfterMs: number`
   - Message: `Rate limit exceeded. Retry after ${Math.ceil(retryAfterMs / 1000)}s`
   - Add TSDoc with @example

2. **isRateLimitError type guard:**
   - Import `DiscogsError` from 'discojs'
   - Returns `error instanceof DiscogsError && error.statusCode === 429`
   - Type predicate: `error is DiscogsError`

3. **calculateBackoff function:**
   - Parameters: `attempt: number`, `baseDelayMs = 1000`
   - Formula: `baseDelayMs * Math.pow(2, attempt)` for exponential
   - Add jitter: `Math.random() * exponential * 0.3` (0-30%)
   - Cap at 60000ms (1 minute max)
   - Return `Math.min(exponential + jitter, 60000)`

4. **delay helper:**
   - `const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))`

5. **withRateLimitRetry generic wrapper:**
   - Signature: `async function withRateLimitRetry<T>(fn: () => Promise<T>, options?: { maxRetries?: number, baseDelayMs?: number }): Promise<T>`
   - Default maxRetries: 3
   - Default baseDelayMs: 1000
   - Loop: for attempt 0 to maxRetries
     - Try: return await fn()
     - Catch: if !isRateLimitError(error), rethrow immediately
     - If attempt === maxRetries: throw new RateLimitError(calculateBackoff(attempt, baseDelayMs))
     - Otherwise: await delay(calculateBackoff(attempt, baseDelayMs))
   - Add TSDoc explaining when to use (wrap discojs calls)

Use .js extension for imports if needed (Vercel serverless compatibility).
</action>
<verify>
`bun run build` succeeds with no TypeScript errors in retry.ts
`grep -r "RateLimitError" src/server/discogs/retry.ts` shows class definition
</verify>
<done>

- RateLimitError class exists with retryAfterMs property
- isRateLimitError correctly identifies DiscogsError with statusCode 429
- withRateLimitRetry wrapper implements exponential backoff with jitter
- All exports are properly typed
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create rate state tracking infrastructure</name>
  <files>src/server/discogs/rate-state.ts</files>
  <action>
Create `src/server/discogs/rate-state.ts` with:

1. **RateLimitState interface:**

   ```typescript
   export interface RateLimitState {
     /** Total requests allowed per minute (60 auth, 25 unauth) */
     limit: number
     /** Requests remaining in current window */
     remaining: number
     /** Unix timestamp (ms) when window resets */
     resetAt: number
     /** Last update timestamp (ms) */
     updatedAt: number
   }
   ```

2. **Default state constant:**
   - Import RATE_LIMIT from '@/lib/constants' (use relative path for serverless: '../../../lib/constants.js')
   - Default: `{ limit: RATE_LIMIT.MAX_REQUESTS, remaining: RATE_LIMIT.MAX_REQUESTS, resetAt: 0, updatedAt: 0 }`

3. **rateLimitState singleton:**
   - Module-level mutable object initialized to default
   - Use `let` for reassignment capability

4. **getRateLimitState function:**
   - Returns readonly copy: `{ ...rateLimitState } as Readonly<RateLimitState>`
   - Prevents external mutation

5. **updateRateLimitState function:**
   - Signature: `(update: Partial<Pick<RateLimitState, 'limit' | 'remaining'>>) => void`
   - Only accepts limit and remaining (other fields computed)
   - If limit provided and valid: update rateLimitState.limit
   - If remaining provided and valid: update rateLimitState.remaining
   - Always set updatedAt to Date.now()
   - Calculate resetAt: updatedAt + RATE_LIMIT.WINDOW_MS

6. **resetRateLimitState function:**
   - Resets to default state
   - Used when window expires or auth changes

Add TSDoc to all exports explaining purpose and usage.
</action>
<verify>
`bun run build` succeeds
`grep -r "RateLimitState" src/server/discogs/` shows interface and usage
</verify>
<done>

- RateLimitState interface matches existing pattern from src/api/rate-limiter.ts
- Singleton state object tracks limit, remaining, resetAt, updatedAt
- updateRateLimitState accepts partial updates
- getRateLimitState returns immutable copy
  </done>
  </task>

<task type="auto">
  <name>Task 3: Export RateLimitError from lib/errors.ts for client use</name>
  <files>src/lib/errors.ts</files>
  <action>
Update `src/lib/errors.ts` to re-export RateLimitError:

1. Add import at top:

   ```typescript
   // Server-side error re-exported for client type checking
   export { RateLimitError } from '@/server/discogs/retry'
   ```

2. Update isNonRetryableError function:
   - Add check for RateLimitError instances (not just tRPC error codes)
   - Pattern: `if (error instanceof RateLimitError) return true`
   - Keep existing tRPC error code checks

This allows client code to:

- Import RateLimitError from '@/lib/errors' (existing pattern)
- Use instanceof checks for error handling
- Access retryAfterMs for UI feedback

Note: The import path uses @/ alias which works in client code. For server-side code importing from this file, the alias also works.
</action>
<verify>
`bun run build` succeeds
`grep "RateLimitError" src/lib/errors.ts` shows re-export
</verify>
<done>

- RateLimitError re-exported from src/lib/errors.ts
- isNonRetryableError updated to recognize RateLimitError instances
- Client code can import RateLimitError from existing error module location
  </done>
  </task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**

   ```bash
   bun run build
   ```

   Must complete with no TypeScript errors.

2. **Export verification:**

   ```bash
   grep -r "export" src/server/discogs/retry.ts src/server/discogs/rate-state.ts
   ```

   Must show all expected exports.

3. **Import chain verification:**

   ```bash
   grep "RateLimitError" src/lib/errors.ts
   ```

   Must show re-export statement.

4. **Vercel build (critical):**
   ```bash
   vercel build
   ```
   Must succeed — serverless functions have stricter module resolution.
   </verification>

<success_criteria>

1. **RATE-01 (partial):** Rate limiting module exists at src/server/discogs/ (full throttle.ts deferred - discojs handles proactive throttling)
2. **RATE-02, RATE-03:** Constants already exist in src/lib/constants.ts (60 req/min, 25 req/min) - rate-state.ts uses them
3. **RATE-04:** 429 errors handled via withRateLimitRetry with exponential backoff + jitter, RateLimitError thrown after exhausted retries
4. **RATE-05:** Rate state exposed via getRateLimitState() for UI consumption
5. **RATE-06 (partial):** Wrapper ready for use - actual wrapping happens in Phase 6 (Facade) and Phase 7 (tRPC Integration)

Infrastructure complete, ready for Phase 6 to wire into facade layer.
</success_criteria>

<output>
After completion, create `.planning/phases/05-rate-limiting/05-01-SUMMARY.md`
</output>
